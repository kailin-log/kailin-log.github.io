[{"content":"JDBC编程基本思路 1. 加载和注册驱动 // 加载JDBC驱动 Class\u0026amp;lt;?\u0026amp;gt; driverClass = Class.forName(\u0026amp;#34;com.mysql.jdbc.Driver\u0026amp;#34;); Driver driver = (Driver)driverClass.getDeclaredConstructor().newInstance(); // 注册驱动 DriverManager.registerDriver(driver); 由于Driver接口的驱动程序类的静态代码块中会自动调用DriverManager.registerDriver()方法，所以加载和注册驱动只需要将驱动类加载到内存即可（加载时会自动调用静态代码块）：\n方法一：通过反射加载类\nClass.forName(\u0026amp;#34;com.mysql.\u0026amp;#34;) 方法二：通过类加载起加载类\nClassLoader.getSystemClassLoader().loadClass(\u0026amp;#34;com.mysql.jdbc.Driver\u0026amp;#34;); 2. 获取数据库链接  DriverManager.getConnection(String url) 此处url格式：jdbc:mysql://localhost:3306/databaseName?user=userName\u0026amp;amp;password=passwordValue DriverManager.getConnection(String url, String user, String password) DriverManager.getConnection(String url, Properties info)通过Properties对象创建连接，Properties对象包含 “user” 和 “password” 两个属性。 从配置文件读取数据创建Properties对象：  # 配置文件config.properties driver=com.jdbc.mysql.Driver url=jdbc:mysql://localhost:3306/databaseName user=userName password=passwordValue Properties info = Properties(); info.load(ClassLoader.getSystemClassLoader().getResourceAsStream(\u0026amp;#34;config.properties\u0026amp;#34;)); 3. 访问数据库 可以通过java.sql包的接口来实现对数据库的访问。\n Statement：用于静态SQL语句并返回产生的结果。 PreparedStatement：对SQL语句语句进行预编译并存储在对象中，并且能实现高效的批处理(存在缓存语句)操作。 CallableStatement：用于执行SQL存储操作。  执行SQL语句：  Statement的int executeUpdate(String SQL)和ResultSet executeQuery(String SQL) PreparedStatement创建预编译SQL语句：  // 占位符使用？表示 PreparedStatement preparedStatement = new PreparedStatement(sql); 通过PreparedState.setXXX(index, value)来填充占位符，使用int executeUpdate()和ResultSet executeQuery()\n获取查询结果 SQL查询语句的结果保存在ResultSet对象中。\n  ResultSet对象维护一个指向当前数据行的游标，通过ResultSet对象的boolean next()方法来向下移动游标。\n  通过getString(String columnLabel)、getInt(String columnLabel)\u0026amp;hellip;方法来获取当前数据行中指定列标签（若没有则为列名称）的值。\n  通过getString(String columnIndex)、getInt(int columnIndex)\u0026amp;hellip;方法来获取当前数据行中指定列的值。(列索引从1开始)\n  Java类型和SQL类型的对应关系\n   Java类型 SQL类型     boolean BIT   byte TINYINT   short SMALLINT   int INTEGER   long BIGINT   String CHAR, VARCHAR, LONGVARCHAR   byte array BINARY, VAR …","date":1593227825,"description":"","lastmod":"2020-06-27T11:17:05+08:00","objectID":"46fd0b11949e7026089bb600da02e1ae","permalink":"https://kailin-log.github.io/javase/jdbc/","publishdate":"2020-06-27T11:17:05+08:00","title":"Jdbc"},{"content":"IoC容器介绍 ​\tSpring把每一个要管理的对象成为Spring Bean，Spring IoC容器是管理Spring Bean的容器。\n所有的IoC容器都需要实现顶层的BeanFactory接口。\nBeanFactory ​\tBeanFactory可以通过五种方式来从容器中获取一个Bean对象\n// 通过Bean的名称来获取Bean对象 Object getBean(String name) throws BeansException; // 通过Bean的名称和类型来获取一个Bean对象 \u0026amp;lt;T\u0026amp;gt; T getBean(String name, Class\u0026amp;lt;T\u0026amp;gt; requiredType) throws BeansException; // 通过Bean的类型来返回一个Bean对象 \u0026amp;lt;T\u0026amp;gt; T getBean(Class\u0026amp;lt;T\u0026amp;gt; requiredType) throws BeansException; Object getBean(String name, Object... args) throws BeansException; \u0026amp;lt;T\u0026amp;gt; T getBean(Class\u0026amp;lt;T\u0026amp;gt; requiredType, Object... args) throws BeansException; ​\t获取IoC容器中Bean信息的方法\n// 判度容器内是否含有名为name的Bean对象 boolean containsBean(String name); // 判断Bean对象是否是单例 boolean isSingleton(String name) throws NoSuchBeanDefinitionException; // 判断Bean对象是否是原型 boolean isPrototype(String name) throws NoSuchBeanDefinitionException; // 判断名为name的Bean对象的类型是否为typeToMatch boolean isTypeMatch(String name, Class\u0026amp;lt;?\u0026amp;gt; typeToMatch) throws NoSuchBeanDefinitionException; // 获取名为name的Bean对象的类型信息 Class\u0026amp;lt;?\u0026amp;gt; getType(String name) throws NoSuchBeanDefinitionException; Bean装配到IoC容器的方法 方法一：通过@Bean注解装配 ​\t配置文件定义\n@Configuration\t//代表配置文件, Spring容器根据配置文件来装配 public class AppConfig { @Bean(name=\u0026amp;#34;user\u0026amp;#34;) // 定义方法的返回值为一个Bean对象，name表示名称 \tpublic User initUser(){ User user = new User(); /*...... User的配置*/ return user; } } ​\t创建IoC容器（Spring通过一个@Configuration定义的配置文件创建容器）\nApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfiguration.class); ​\t ApplicationContext是继承自BeanFactory的容器接口，AnnotationConfigApplicationContext是 Applicationontext的实现类，是一个基于注解的容器。\n通过@Bean装配的优势 ​\t可以自定义第三方Bean。\n方法二：通过@Component和@ComponentScan来扫描装配Bean ​\t使用@Component来表明哪个类要装配进容器，再通过@Value注解来指定类属性的值\n@Component public class User { @Value(\u0026amp;#34;1\u0026amp;#34;) private Long id; @Value(\u0026amp;#34;user_name_1\u0026amp;#34;) private String userName; ​\t使用@ComponentScan注解来扫描需要装配到容器的Bean\n@ComponentScan public class AppConfiguration {/* ... */} ​\t\t@ComponentScan注解标注的扫描类默认只会扫描对应类所在文件夹及其子文件夹下的Bean对象。(可以通过basePackages属性自定义扫描的包） …","date":1592834698,"description":"","lastmod":"2020-06-22T22:04:58+08:00","objectID":"ca36f4b2b25ea29b9d75286fb0122180","permalink":"https://kailin-log.github.io/spring-boot/ioc%E5%AE%B9%E5%99%A8/","publishdate":"2020-06-22T22:04:58+08:00","title":"IoC容器"}]